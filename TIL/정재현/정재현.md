# 정재현

### 3/4
#### CPU, 메모리, 디스크

CPU

명령어를 해석하고 실행
연산작업을 한다.


메모리

CPU가 작업하기 위해 임시로 사용하는 공간
디스크보다 메모리로부터 데이터를 가져올 때 속도가 빠르다
CPU는 명령어를 해석해서 실행하거나 연산 작업을 할 때는 메모리를 통해서 데이터를 가져온다
실행할 프로그램의 코드, 변수가 있다 (전역 변수, 파라미터,...)
RAM 이라고도 부른다


디스크

C 드라이브와 같은 컴퓨터 저장 공간
영구적으로 데이터, 파일 등을 저장
데이터를 가져올 때 메모리 보다 속도가 상대적으로 느리다


우선 성능을 올리는 방법은 그냥 스펙을 올리는 방법이 있다. 즉, 하드웨어 업그레이드를 하는 방법이다.



하지만 하드웨어 업그레이드는 비용이 많이 든다.



그럼 다른 방법으로는 소프트웨어 최적화 시키는 것이다.

성능 측정을 하기 위해 우리는 아키텍처를 봐야하고 집중적으로 봐야 할 점은 DB와 백엔드 서버이다.



그럼 DB와 백엔드 서버는 CPU, 메모리, 디스크를 어떻게 사용할까?



1. DB

디스크로부터 데이터를 조회해서 메모리에 올림
메모리에서 연산, 필터링, 집계 등의 작업을 CPU 가 처리
DB의 특성상 많은 양의 데이터를 가지고 작업을 해야 하는 경우가 빈번해서 CPU, 메모리 둘 다 많이 사용하는 편이다
2. 백엔드 서버

백엔드 서버의 로직에 파일 읽어오거나 파일을 생성하는 로직이 없다면 디스크는 거의 사용할 일이 없다
파일 처리 같은 건 S3를 이용한다
DB로 부터 불러오는 데이터의 양이 크지 않은 경우에는 메모리를 많이 사용할 일이 없다
많은 요청에 대해 로직을 처리해야 하기 때문에 CPU를 많이 사용하는 편이다
복잡한 연산 작업(인코딩, 디코딩, 암호화)을 사용할 경우 CPU를 많이 사용한다
3. 로드벨런서

요청이 들어오면 적절하게 서버들 한테 골고루 트래픽을 분배해준다
임시로 저장해야 하는데이터가 많은게 아니기 때문에 메모리를 많이 사용할 일이 없다
많은 요청을 분배해주는 로직을 처리하기 때문에 CPU를 많이 사용




4. 캐시

캐시의 특성상 빠르게 데이터를 조회해야 하기 때문에 메모리에 데이터를 저장한다

---

### 3/5
#### try-with-resource에 대해서 설명

- 기존 try-catch-finally 에서 발전된 형태로 finally에서 자원을 닫는 부분이 나오는데 예상치 못한 에러가 발생해서 finally 구문이 실행이 안된는 단점을 보완한 형태입니다 try-with resources가 자동으로 close() 메서드를 호출하여 자원을 안전하게 해제합니다.


#### try-with-resource를 사용하면서 AutoCloseable 인터페이스의 중요성

- Autocloseable은 try-with-resources 구문에서 사용될 수 있도록 객체가 close() 메서드를 구현하도록 강제하는 인터페이스이다

---

### 3/7
####ACID 트랜잭션 속성

Atomicity  원자성

- ALL or NOTHING
- 트랜잭션은 논리적으로 쪼개질 수 없는 작업 단위이기때문에 내부의 SQL 문들이 모두 성공해야함
- 중간에 SQL문이 실패하면 지금까지의 작업을 모두 취소하여 아무 일도 없었던것처럼 롤백한다

커밋 실행시 영구적으로 저장하는건 DBMS가 담당하는 부분
롤백 실행시 이전 상태로 되돌리는것도 DBMS가 담당하는 부분
개발자는 언제 커밋하거나 롤백 할지를 챙겨야함


Consistency - 일관성

- DB 상태를 consistent 상태에서 또 다른 consistent 상태로 바꿔야함
- constraints, trigger 등을 통해 db 에 정의된 rules 을 transaction이 위반했다면 roll back 해야함
- trasaction이 DB에 정의된 rule을 위반했는지는 DBMS가 commit 전에 확인하고 알려준다
- 개발자는 application 관점에서 consistent 하게 transaction이 동작하는지 확인해야함


Isolation

- 여러 트랜잭션들이 동시에 실행될 때도 혼자 실행되는 것처럼 동작하게 만든다
- isolation level을 제공
- 개발자는 isolation level 중에 어떤 level로 트랜잭션을 동작시킬지 설정할 수 있음
- concurrency control의 목표가 isolation


Durability - 영존성
- commit 된 트랜잭션은 db에 영구적으로 저장

---
