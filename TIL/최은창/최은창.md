# 최은창


# 25, 03, 05

### 디지털 지갑
디지털 지갑은 암호화폐, 디지털 신원 정보, 인증서 등을 저장하고 관리하는 소프트웨어 또는 하드웨어를 의미한다.

**주요 특징**
* 암호화폐(예: 비트코인, 이더리움 등) 저장 및 거래 가능
* 개인 키(Private Key)를 안전하게 저장하여 신원 증명 및 서명 기능 수행
* DID 같은 디지털 신원 정보(Digital Credentials)도 저장할 수 있음
* 스마트폰 앱(MetaMask, Trust Wallet)또는 하드웨어(Ledger, Trezor) 형태로 제공됨

**디지털 지갑의 역할**
* 암호화폐 거래 및 관리
* DID 및 증명서(VC, Verifiable Credential)저장 및 제어
* 블록체인 기반 로그인 및 인증(비밀번호 없이 로그인 가능)


### DID (Decentralized Identifier, 분산 신원)
DID는 탈중앙화된 디지털 신원을 위한 고유한 식별자로, 중앙기관 없이 개인이 직접 신원 정보를 관리할 수 있도록 설계됨.

**주요 특징**
* 블록체인 기반의 고유한 식별자(예 did:example:1218671)
* 정부나 기업이 아닌 사용자가 직접 신원 정보 관리 가능
* 신뢰할 수 있는 기관이 제공하는 증명서(VC)를 이용하여 신원 증명 가능
* 디지털 지갑에서 DID를 저장하고 활용할 수 있음

** DID의 역할
* 신원 증명 (예: 디지털 운전 면허증, 졸업 증명서)
* 자기주권 신원(Self-Sovereign Identity, SSI) 지원 -> 사용자가 자신의 신원을 직접 관리
* 비밀번호 없는 로그인(예: 블록체인 기반 서비스에서 DID 로그인)


**정리하자면..**

|**비교 항목**|**디지털 지갑**|**DID(분산신원)**|
|---|---|---|
|개념|디지털 자산(암호화폐, 인증서 등) 저장 및 관리 도구|블록 체인 기반의 고유한 신원 식별자|
|역할|암호화폐 거래, DID 및 증명서 저장, 전자 서명|신원 증명, 자기주권 신원, 비밀번호 없는 인증|
|저장 방식|소프트웨어/하드웨어 형태의 지갑 앱|블록체인에 저장된 고유 식별자자|

1. 디지털 지갑이 DID를 저장하고 관리할 수 있음
2. DID를 이용한 신원 증명 과정에서 디지털 지갑이 사용자 서명 및 검증 역할을 수행
3. DID와 함께 검증 가능한 증명서(VC)가 함께 활용됨

![image.png](./image.png)


DID는 신원을 식별하는 고유한 ID이며, 디지털 지갑은 그 ID 및 관련 데이터를 저장하고 사용하는 도구라고 이해하면 됨됨


# 25, 03, 06

### DID(Decentralized Identifier, 분산 신원)
DID는 **중앙 기관 없이 개인이 직접 자신의 신원을 증명할 수 있도록 만들어진 고유한 식별자(ID)**다.

**DID의 특징**
* 중앙기관(예: 정부, 은행)없이 사용자가 직접 신원을 관리
* W3C 표준에 따라 블록체인과 상관없이 DID 생성 가능
* DID를 통해 신원 증명서(VC)를 발급, 검증 가능

**DID는 신원을 나타내는 ID일 뿐, 직접 블록체인에 저장되는 것은 아님**
* DID 자체는 블록체인에 저장되지 않을 수도 잇음(DID는 반드시 블록체인을 필요로 하지 않음)
* 다만, DID를 발급하고 검증할 때 블록체인을 사용할 수 있음

### 블록체인 정보

블록체인은 **중앙 서버 없이 정보를 안전하게 저장하고 검증하는 분산 원장 기술** 이다.

**블록체인의 특징**
* 데이터를 조작할 수 없도록 암호화된 분산 저장 방식
* 거래 기록, 스마트 계약. DID 관련 메타데이터 등을 저장는 기능

* 블록체인은 DID 외에도 다양한 정보를 저장할 수 있음
* 암호화폐 거래 내역
* 스마트 계약
* 분산 애플리케이션(DApp) 관련 데이터
* DID의 공개 키, 신원 발급 기관 정보 등

# 25, 03, 07

### 중앙화 vs 탈중앙화 속도 차이

* 중앙화 시스템 (visa 등) : 1초당 약 2000건 처리 가능, 사용 가능까지 약 3분 소요
* 탈중앙화 시스템(블록체인) : 1초당 약 20건 처리 가능, 평균 10번의 인증(블록 생성)이 필요하여 처리 속도가 느림


### Solidify 개요
* Solidify는 스마트 컨트랙트를 작성하기 위한 언어
* **EVM**을 타겟으로 설계
* 정적타입 언어이며, 상속, 라이브러리, 사용자 데이터 타입 지원
* 스마트 컨트랙트 특징
  * 블로겣인에 업로드 되면 수정 불가, 누구나 확인 가능 -> 신뢰성 높음
  * 코드 작성 시 신중함 필요
* Remix IDE
  * 웹 기반 Solidity 개발 환경
  * 스마트 컨트랙트를 작성하고 실행 테스트 가능

### Solidity 문법 및 개념
#### 스마트 컨트랙트 구조
* 클래스와 유사한 개념으로 구성
  * 상태 변수
  * 함수 및함수 변경자(Modifier)
  * 이밴트(Event)
  * 구조체 (Struct), 열거형(Enum)
  * 상속 및 다형성 지원

#### 데이터 타입
* 문자열: `string`, `byte12` (UTF-8)지원
* 맵핑(Mapping) : `key-value`쌍으로 데이터를 저장(`adress` -> `string` 매핑 예제)
* 배열
  * 정적 배열 : 크기 고정
  * 동적 배열 : 블록체인상에서 지속적으로 추가 가능 -> 데이터베이스처럼 활용 가능
* 인터페이스 (Interface) 추상 계층 설계 가능

#### Modifier(한정자)
* 함수실행 조건을 정의

#### 데이터 저장 위치
* storage : 블록체인에 영구 저장(전역변수)
* memory : 휘발성 메모리(로컬변수)

#### 제어문
* `if`, `else`, `while`, `for`, `break`, `continue`, `return`, 삼항연산자(`? :`) 지원

#### 가시성(Visibility)

|접근제한자|설명|
|---|---|
|`public`|내부 및 외부에서 접근 가능 (자동 Getter 생성)|
|`external`|트랜잭션 또는 다른 컨트랙트에서만 호출 가능(this.f() 필요)|
|`internal`|내부 컨트랙트 및 상속된 컨트랙트에서만 접근 가능|
|`private`|내부 컨트랙트에서만 접근 가능 (상속된 컨트랙트에서도 접근 불가)|

#### 가스(Gas) 개념
* **EVM에서 실행되는 모든 작업에는 수수료(Gas) 필요**
* **가스 = 가스 가격(Gas Price) x 가스 사용량(Gas Used)**
* **가스 리밋(Gas Limit)**
  * 트랜잭션에 사용할 최대 가스 설정
  * 너무 낮게 설정하면 실행 도중 종료되며 사용한 가스는 반환되지 않음
* **가스 프라이스(Gas Price)**
  * 단위 가스당 가격
  * 가격이 높을수록 우선적으로 채굴됨

# 25, 03, 10
## Refresh Token을 사용하는 이유

> **잠깐! Redis는 무엇인가?**
> 레디스는 **인메모리 방식**의 데이터베이스다.


### 베이직 DB와 In-Memory DB 차이
* 기존 DB(mysql, postgreSQL)
	* 보조기억장치(HDD,SDD)에 데이터를 저장한다. 그래서 많은 양의 데이터를 오래 저장하는데 적절하다.
* 인메모리 DB(Redis, MemCache)
	* 주기억장치에 데이터를 저장한다. 그렇기 때문에 조회 성능이 월등히 빠르다.

**단!,** 주기억 장치를 이용하기 때문에 RAM의 휘발성 메모리의 특징도 가지고 있다. 그래서 중요한 데이터의 삭제를 예방하기 위해 fork 기능을 사용하여 보조기억장치에 저장하기도 한다.

> **Radis의 특징 3가지**
> 1. Key-Value 구조
> 2. 데이터 만료시간 설정 가능
> 3. 수평적 확자에 용이

위 특징 때문에 자주 조회되는 값인 Refresh Token을 Redis에 사용하자 라는 말이 많다. 하지만 해당 방식은 아무런 의미가 없다??



## 왜 Refresh Token을 사용할까?

* 완벽한 보안은 존재하지 않다.
* 세션 베이스(statefull) 인증과 '토큰'은 상호 대체적이지 안다.
	* 세션 베이스 인증에서도 토큰을 사용한다.

### 엑세스 토큰의 한계점
*  **잦은 로그아웃**
	* 엑세스 토큰을 단독으로 사용하면 **재발급 시 로그인**을 해야한다.
		* 때문에 만료시간을 짧게 하면 재로그인을 자주 해야하며, 만료시간을 길게하면 아래와 같은 보안 문제가 발생한다.
*  **보안 문제**
	* Access Token의 만료 시간을 길게하면 탈취 당했을 때 유저의 모든 권한을 탈취자가 가지게 된다.
	* 토큰은 statle-less 구조로 state의 주도권을 서버가 가지고 있지 않다.
	* 때문에 탈취 당했다고 하더라도 토큰 자체를 파기할 수 없다.
		* (이는 비용적으로는 장점이지만, 보안적으로는 단점이다.)

### Refresh Token이란?
Refresh Token은 Access Token의 문제점을 방지하기 위해 생겨났다.

* **잦은 로그아웃**
	* Refresh Token을 사용하여 Access Token을 갱신하여 재로그인 주기를 늘릴 수 있다.
* **보안 문제**
	* Access Token의 만료시간을 짧게 함으로써 탈취 시 문제를 조금이나마 방지할 수 있다.


# Refresh Token 탈취 시
* Refresh Token의 한계다. 서버 측에서의 대응이 불가능하다.
	* 이를 예방하기 위해 여러가지 Refresh Token 전략이 존재한다.
	* **상호 대체적인 전략도 존재하며, 상호 보완적 전략도 존재한다.**

## RTR(Refresh Token Roataion)전략
RTR은 Refresh API 사용 시, Acces Token과 함께 Refresh Token을 갱신시켜버리는 방식이다. RTR의 핵심은 **Refresh Token을 1회용으로 구현**하는 것이다.

구현 방식으로는 DB에 저장, rotation_tpye 옵션 사용, Refresh Token의 짧은 만료시간 등이 있다.

대신 XSS 취약점을 사용한 공격은 막지 못한다.

## Refresh Token에 http-only 적용 전략
Access Token은 Http Authorization header에 담아야하기 때문에 노출되는 것을 막을 수 없다. 하지만 리프레시 토큰을 사용할 때는 `http only`옵션을 사용하여 쿠키로 보낸다. JS에선는 Refresh Token에 접근할 수 없기 때문에 위 XSS공격을 예방할 수 있다.

**다만, 이 방법 또한 csrf(Cross-site request forgery)을 사용하면 탈취할 수 있다.**


## Access Token 만료시간 단축 전략
위에서 설명했던 부분이지만, 엑세스 토큰의 만료 시간을 짧게 설정하여 탈취 시 문제를 조금이나마 방지할 수 있다.
* 재발급이 횟수가 늘어나겠지만, **탈취 리스크를 줄이기 위해 권장**하는 방식이다.

## 사용자 정보를 Access Token에 저장 전략
발급 당시 IP, 기기/브라우저 정보 등을 저장하고 엑세스  토큰을 사용하는 자의 정보와 크게 다르다면 재로그인을 수행하는 전략이다. 이 또또한 권장한다.

## Token DB 저장 전략
Access/Refresh Token을 계정에 엑세스 토큰이 1:1로 매핑되도록 DB에 저장하는 방식이다. 
Refresh API를 수행할 때 이미 발급된 Access Token이 탈취 되었을 때 인증서버에서 거부할 수 있다.
이렇게 하면 State-less 구조의 장점을 잃어버린다. 이 방식으로 사용 할 바에는 세션을 사용하는게 맞다 **(Redis를 사용하는 이유에는 보안적인 이유는 없다.)**

## Refresh Token의 한계점
Refresh Token은 한계점이 명확하다. 보안적 역할을 하지 못한다는 평가도 존재한다.
+ 탈취된 Access Token을 만료시킬 수 없다.
+ Refresh Token이 탈취 된다면 결국 아무것도 할 수 없다.


## 이렇게 사용한다(기타 의견)
브라우저 환경인 웹 서비스는 Session을 사용하여 보안성을 가져가고
모바일 환경에서는 상대적으로 해킹이 어렵기 때문에 Token 방식을 사용한다.


# 25, 03, 11

## 순위에 RDB를 사용하지 않는 이유

## 실시간 성능 문제
랭킹 시스템은 보통 실시간으로 데이터를 업데이트 하고 빠르게 조회해야 한다. `RDB`는 데이터 일관성을 유지하기 위해 트랜잭션 관리와 락(lock) 메커니즘을 사용하기 때문에 대량의 쓰기/ 읽기 작업이 반복되는 경우 성능이 저하될 수 있다.

* 랭킹 업데이트 : RDB에서 순위를 계산하려면 매번 정렬 및 순위 계산을 해야할 수 있다. 이는 많은 데이터를 처리해야 하는 경우 매우 느려질 수 있다.
* 실시간 요구사항 : 사용자 수가 많고 랭킹이 자주 변동되는 경우, RDB는 높은 TPS(Transaction Per Second)를 처리하기 어렵다.

## 확장성 문제
`RDB`는 수평 확장이 어려운 경우가 많다. 반면, 랭킹 시스템은 사용자 수가 급격히 증가하거나 데이터 볼륨이 클 경우 수평 확장이 용이한 구조가 필요하다.
* `RDB`는 테이블의 스케일아웃(수평 확장) 보다는 스케일업(하드웨어 성능 강화)에 의존하는 경향이 있어 확장성이 떨어질 수 있다.
* 랭킹 시스템은 대규모 트래픽을 처리해야 하므로 `NoSQL`같은 분산 데이터베이스나 메모리 기반 데이터 저장소(Redis 등)를 사용하는 것이 더 적합할 수 있다.

## 일관성(CAP 이론)의 트레이드오프
랭킹 시스템은 엄격한 데이터 일관성보다 가용성과 성능이 더 중요할 때가 많다. RDB는 [[ACID]] 특성을 제공하지만 이는 성능에 영향을 미칠 수 있다.
* 랭킹 데이터는 실시간으로 자주 변경되고, 일관성 문제가 허용되는 경우가 많다.
* NoSQL이나 Redis를 사용하면 약간의 일관성을 희생하더라도 더 바른 처리 속도를 얻을 수 있다

## Redis와 같은 데이터 저장소의 적합성
랭킹 시스템에서는 보통 Redis와 같은 메모리 기반 데이터 저장소가 많이 사용된다. 이는 랭킹 데이터를 효율적으로 처리하기 위한 적합한 도구를 제공한다.
* `Sorted Set` : Redis의 Sorted Set은 행킹 데이터를 저장하고, 정렬된 상태로 유지하며, 특정 범위의 데이터를 빠르게 조회할 수 있도록 설계되었다.
* `TTL` : 랭킹 시스템에서 데이터의 유효기간을 설정할 수 있어 오래된 데이터를 자동으로 제거할 수 있다.
* `빠른 조회와 업데이트` : 메모리 기반으로 동작하기 떄문에 데이터 조회와 업데이트 속도가 매우 빠르다.

## 비관계형 데이터 모델의 유연성
랭킹 시스템은 보통 단순한 데이터 모델(사용자 ID,  점수 등)을 사용한다. 이런 데이터는 관계형 모델보다는 키-값 또는 정렬된 집합 데이터 모델에서 더 효과적으로 처리할 수 있다.


## 결론
`RDB`는 일반적인 CRUD 작업에는 적합하지만, 랭킹 시스템처럼 대량의 실시간 데이터를 고속으로 처리해야 하는 경우에는 Redis, MongoDB 같은 대체 기술이 더 적합한 경우가 많다. 특히, `Redis`의 **Sorted Set**을 활용하면 성능과 확장성을 동시에 확보할 수 있어 랭킹 시스템에 적합하다.

# 25. 03. 12

## ORM(Object-Relational Mapping)

* JPA에 대해서 알기전에 기본이 되는 **ORM에 대해서 알아야** 된다.
* ORM : 객체는 객체대로 설계하고, RDB(관계형 데이터베이스)는 RDB 대로 설계한다.
* 프레임워크로 객체와 RDB를 중간에서 서로 매핑해주는 역할을 담당한다.
* 대중적인 언어에는 대부분 ORM 기술이 존재한다.

### 1-1 ORM vs SQL Mapper(Mybatis, Spring jdbcTemplate)
* ORM
  * DB 테이블을 Java 객체로 Mapping(매핑) 함으로써 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성(객체를 통해 간접적으로 DB 데이터를 조작)
  * DB 데이터 <- Mapping -> Object 필드
  * SQL 쿼리가 아니라 메서드로 데이터를 조작
  * 객체간 관계를 바탕으로 SQL을 자동으로 생성

* SQL Mapper
  * SQL을 직접 명시(SQL 문으로 직접 디비를 조작)
  * SQL <- Mapping -> Object 필드

* ORM은 RDB의 관계를 Object에 반영하는 것이 목적이라면, SQL Mapper는 단순히 필드를 매핑시키는 것이 목적이라는 차이점이 있다.

### JPA(Java-Persistence API)란?
* java 진영에서의 ORM 기술 표준으로, Java Application에서 RDB를 사용하는 방식을 정의한 인터페이스의 모음이다.
* 즉 실제로 동작하는 것이 아닌 인터페이스를 구현하여 사용한다.(대표적으로 Hibernate)
* JPA 2.1 표준 명세를 구현한 3가지 구현체
  * Hibernate
  * EclipseLink
  * DataNucleus
* SQL 작성없이 객체를 데이터베이스에 직접 저장할 수 있게 도와주는 기술로 Application과 JDBC사이에서 동작한다.

### SQL을 직접 다룰 때의 문제접(ex: MyBatis)
1. 반복적인 코드의 작성
	* 모든 DB 작업에 대한 SQL 문을 작성해야 한다.
	* 반복적인 CRUD SQL 작성과 객체 SQL에 매핑하는 코드를 작성하는데 시간이 오래 걸린다.
2. SQL 의존적 개발
	* 테이블에 Column이 추가된다면 모든 DAO의 SQL문 변경이 필요하다.
	* 만약 동작하지 않으면 Java에서의 로직과 SQL문 둘 다 확인이 필요하다.
3. 패러다임의 불일치
	 * Java는 객체지향 언어이지만, RDB(관계형 데이터베이스)는 객체지향이 다루는 개념이 존재하지 않고 서로 지향하는 목적이 다르기 때문에 패러다임의 불일치가 발생한다.
	 * 이러한 서로 다른 목적 떄문에 개발자가 중간에서 문제를 해결하기 위해 직접 코드를 작성해서 매핑해야 한다.

### JPA 장단점

**장점**

1. 생산성
	* JPA에 객체를 전달만 하면 되므로 SQL을 작성하고 JDBC API를 사용하는 반복적인 일을 JPA가 대신 처리해주어 생산성이 향상된다.
	* DDL도 JPA가 자동으로 생성해주기 때문에 DB 설계 중심으로 변경할 수 있다.
2. 유지 보수
	* SQL을 직접 다룰 때는 필드를 하나를 추가/삭제하여도 관련된 SQL과 JDBC코드를 전부 수정해야 했지만, JPA는 이를 대신 처리해주어 유지보수가 줄어든다.
3.  패러다임의 불일치 해결
	* JPA는 연관된 갹체를 사용하는 시점에서 SQL을 전달할 수 있고, 같은 트랜잭션 내에서 조회할 때 동일성도 보장하기 때문에 다양한 패러당미의 불일치를 해결한다.
4. 성능
	* 어플리케이션과 데이터베이스 사이에서 성능 최적화 기능을 제공한다.
	* 같은 트랜잭션 안에서는 같은 엔티티를 반환하기 때문에 통신 횟수를 줄일 수 있다.
5. 데이터 접근 추상화와 벤더 독립성
	* RDB는 같은 기능이라도 벤더마다 사용법이 다르기 때문에 처음 선택한 DB에 종속되고 변경이 어렵다.
	* JPA는 어플리케이션과 데이터베이스 사이에서 추상화된 데이터 접근을 제공하여 종속되지 않도록 도와준다.


**단점**

1. 학습 곡선이 높다.
	* JPA를 사용하려면 객체와 관계형 데이터베이스를 어떻게 매핑해야 하는지 학습한 후에 JPA의 핵심 개념들을 이해해야 한다.
	* JPA의 핵심 개념인 영속성 컨택스트에 대한 이해가 부족하면 SQL을 직접 사용해서 개발하는것보다 못한 상황이 발생할 수 있다.
2. 속도 저하 가능성이 있다.
	* 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨릴 수 있다.
	* 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야 할 수 있다.

### 동작 과정
![image-3.png](./image-3.png)
 * JPA는 어플리케이션과 JDBC API 사이에서 동작한다.
 * 개발자가 JPA를 사용하면, JPA 내부에서는 JDBC API를 사용하여 SQL을 생성하고 DB와 통신한다.
	* JPA에서의 CRUD
```sql
jpaEm.persist(member);// 저장
jpaEm.fid(memberId);  //조회
jpaEm.remove(member); //삭제

// 수정(조회 이후 해당 객체에 변경하면 DB에도 변경된다.)
// 영속성 컨텍스트

Member.member = jpaEm.find(memberId);
member.setName("변경할 이름);
```

* JPA에서는 수정 매소드를 제공하지 않는다.
* 하지만 수정은 필요한 동작이기 때문에 JPA에서는 데이터 수정 시, 매핑된 객체(테이블 데이터)를 조회해서 값을 변경 후 커밋하면 DB 서버에서 UPDATE문으로 바꾸어 UPDATE를 실행한다.

#### 5-1. 저장(persist = insert)
![image-2.png](./image-2.png)

* Member 를 저장할 때, JPA는 아래와 같이 동작한다.
	1. Member객체를 JPA에 넘긴다.
	2. JPA는 객체의 엔티티(Entity)를 분석한다.
	3. JPA에서 INSERT 쿼리(SQL)를 생성한다.
	4. JPA가 JDBC API를 사용하여 생성한 SQL를 DB에 요청한다.
#### 5-2. 조회(find = select)
![image-1.png](./image-1.png)
* Member를 조회할 때, JPA는 아래와 같이 동작한다.
	1. Member 객체 필드에서 PK(Primary Key)값을 JPA에 넘긴다.
	2. JPA에서 Member 엔티티(Entity)의 매핑 정보를 바탕으로 쿼리를 생성한다.
	3. JPA가 JDBC API를 사용하여 생성한 SQL를 DB에 요청한다.
	4. JPA가 JDBC API를 통해 DB로 부터 결과를 받아온다.
	5. JPA는 결과(ResultSet)를 객체(Member)의 Entity에 맞게 모두 매핑한다.
* 쿼리를 JPA가 만들어 주기 때문에 Object와 RDB 간의 패러다임 불일치를 해결 할 수 있다.

### 6. JPA 어노테이션 종류
* JPA는 어노테이션을 분석하여 어떤 객체가 어떤 테이블과 관계가 있는지를 알아낸다.

|어노테이션|설명|
|---|---|
|@Entity|데이터베이스의 테이블과 일대일로 매칭되는 객체 단위이며, 클래스를 테이블과 매핑한다고 JPA에게 알린다.|
|@Table|@Entity 선언된 클래스에 매핑할 테이블정보(테이블 이름)을 알려준다.이 어노테이션이 생략되면 클래스 이름을 테이블 이름으로 매핑한다.|
|@cloumn|데이터베이스의 테이블에 있는 컬럼에 필드(변수)를 매핑한다. 별다른 옵션을 설정하지 않는다면 기본적으로는 생략이 가능하다.|
|@id|@Entity 선언된 클래스의 필드를 테이블의 기본키(Primary Key)에 매핑한다.|
|@GeneratedValue|새로운 레코드가 생성될 때마다 마지막 PK 값에서 자동으로 +1 을 해줘야 하는 auto Increment 컬럼인 것을 알려준다.
|@Embeddedid|복합키로서 정의된 값을 정의하고자 할 때 사용한다.|
|@Enumerated|Java의 Enum 형태로 되어 있는 미리 정의되어 있는 코드 값이나 구분 값을 데이터 타입으로 사용할 때 사용한다.|
|@Transient|Entity 객체 에 속성으로 지정되어 있지만, 데이터베이스에서는 필요 없는 속성일 때 사용한다.|

# 25. 03. 13

리엑트는 효율적인 UI 구현을 위한 라이브러리다. `HTTP client(HTTP 상에서 커뮤니케이션을 하는 자바 기반 컴포넌트)`를 내장하고 있는 Angular와는 다르게, 리액트는 따로 내장 클래스가 존재하지 않는다.

따라서 리엑트에서 Ajax를 구현하려면 JavaCript 내장객체인 XMLRequest를 사용하거나, 다른 HTTP Client를 사용해야 한다.

> 짚고 넣어가기
>
> **💡AJAX(Asnchronous Javascript And XML)**
>
> Javasciprt의 라이브러리 중 하나이며, Asynchronous javascript And Xml(비동기식 자바스크립트와 xml)의 약자다. 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 **전체 페이지를 새로 고치지 않고도 페이지 일부만**을 위한 데이터를 로드하는 기법이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이다. 정리하자면, 자바스크립트를 통해서 서버에 데이터를 요청하는 것이다.
>
> **💡비동기 방식이란?**
>
> 비동기 방식은 웹페이지르르 리로드하지 않고 데이터를 불러오는 방식이며, Ajax를 통해서 서버에 요청을 한 후 멈춰 있는 것이 아니라 그 프로그램은 계속 돌아간다는 의미를 내포하고 있다.
>
> ![image-5.png](./image-5.png)
>
> **비동기 방식의 장점**
>
> 페이지 리로드의 경우 전체 리소스를 다시 불러와야하는데 이미지, 스크립트, 기타 코드등을 모두 재요청할 경우 불필요한 리소스 낭비가 발생하게 되지만 비동기식 방식을 이용할 경우 필요한 부분만 불러와 사용할 수 있으므로 매우 큰 장점이 있다.

## Axios vs Fetch API

우리는 일반적으로 자바스크립트에서 API를 연동하기 위해서 보통 `Fetch API`를 사용하곤 했다. 리액트도 자바 스크립트 built-in 라이브러리 중 하나인 Fetch API 라는 훌륭한 API 연동 모듈을 사용한다. 하지만 Fetch API는 자바 스크립트의 Built-in 라이브러리라는 특성 때문인지 많은 사람들이 리엑트에 axios를 사용하는 것을 선호한다.
![image-6.png](./image-6.png)

## 🤔그렇다면 많은 사람들이 왜 Fetch API말고 Axios를 더 선호할까?

### Fetch API
```javascript
const url = 'http://localhost3000/test'
const option = {
	method: 'POST',
	header: {
		'Accept' : 'application/json',
		'content-Type' : 'application/json'; charset=UTP-8'
	},
	body: JSON.stringify({
		name: 'sewon',
		age:20
	})

	fetch(url,options).then(response => console.log(response))
}
```

### axios
```javascript
const option = {
	url = 'http://localhost3000/test'
	method:'POST'
	header:{
		'Accept' : 'application/json',
		'Content-Type' : 'application/json'; 'charset=UTP-8'
	},
	data: {
		name : 'sewon'
		age:20
	}
	axios(options).then(response => console.log(response))
}
```

## Axios
axios는 브라우저, Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리다. (백엔드와 프론트엔드와 통신을 쉽게하기 위해 AJAX도 더불어 사용하기도 한다.)

## Axios 특징
* 운영 환경에 따라 브라우저의 XMLHttpRequest 객체 또는 Node.js의 HTTP API 사용
* Promise(ES6) API 사용
* 요청과 응답 데이터의 변형
* HTTP 요청 취소 및 요청과 응답을 JSON 형태로 자동 변경





