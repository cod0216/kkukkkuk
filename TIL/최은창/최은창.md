# 최은창


# 25, 03, 05

### 디지털 지갑
디지털 지갑은 암호화폐, 디지털 신원 정보, 인증서 등을 저장하고 관리하는 소프트웨어 또는 하드웨어를 의미한다.

**주요 특징**
* 암호화폐(예: 비트코인, 이더리움 등) 저장 및 거래 가능
* 개인 키(Private Key)를 안전하게 저장하여 신원 증명 및 서명 기능 수행
* DID 같은 디지털 신원 정보(Digital Credentials)도 저장할 수 있음
* 스마트폰 앱(MetaMask, Trust Wallet)또는 하드웨어(Ledger, Trezor) 형태로 제공됨

**디지털 지갑의 역할**
* 암호화폐 거래 및 관리
* DID 및 증명서(VC, Verifiable Credential)저장 및 제어
* 블록체인 기반 로그인 및 인증(비밀번호 없이 로그인 가능)


### DID (Decentralized Identifier, 분산 신원)
DID는 탈중앙화된 디지털 신원을 위한 고유한 식별자로, 중앙기관 없이 개인이 직접 신원 정보를 관리할 수 있도록 설계됨.

**주요 특징**
* 블록체인 기반의 고유한 식별자(예 did:example:1218671)
* 정부나 기업이 아닌 사용자가 직접 신원 정보 관리 가능
* 신뢰할 수 있는 기관이 제공하는 증명서(VC)를 이용하여 신원 증명 가능
* 디지털 지갑에서 DID를 저장하고 활용할 수 있음

** DID의 역할
* 신원 증명 (예: 디지털 운전 면허증, 졸업 증명서)
* 자기주권 신원(Self-Sovereign Identity, SSI) 지원 -> 사용자가 자신의 신원을 직접 관리
* 비밀번호 없는 로그인(예: 블록체인 기반 서비스에서 DID 로그인)


**정리하자면..**

|**비교 항목**|**디지털 지갑**|**DID(분산신원)**|
|---|---|---|
|개념|디지털 자산(암호화폐, 인증서 등) 저장 및 관리 도구|블록 체인 기반의 고유한 신원 식별자|
|역할|암호화폐 거래, DID 및 증명서 저장, 전자 서명|신원 증명, 자기주권 신원, 비밀번호 없는 인증|
|저장 방식|소프트웨어/하드웨어 형태의 지갑 앱|블록체인에 저장된 고유 식별자자|

1. 디지털 지갑이 DID를 저장하고 관리할 수 있음
2. DID를 이용한 신원 증명 과정에서 디지털 지갑이 사용자 서명 및 검증 역할을 수행
3. DID와 함께 검증 가능한 증명서(VC)가 함께 활용됨

![image.png](./image.png)


DID는 신원을 식별하는 고유한 ID이며, 디지털 지갑은 그 ID 및 관련 데이터를 저장하고 사용하는 도구라고 이해하면 됨됨


# 25, 03, 06

### DID(Decentralized Identifier, 분산 신원)
DID는 **중앙 기관 없이 개인이 직접 자신의 신원을 증명할 수 있도록 만들어진 고유한 식별자(ID)**다.

**DID의 특징**
* 중앙기관(예: 정부, 은행)없이 사용자가 직접 신원을 관리
* W3C 표준에 따라 블록체인과 상관없이 DID 생성 가능
* DID를 통해 신원 증명서(VC)를 발급, 검증 가능

**DID는 신원을 나타내는 ID일 뿐, 직접 블록체인에 저장되는 것은 아님**
* DID 자체는 블록체인에 저장되지 않을 수도 잇음(DID는 반드시 블록체인을 필요로 하지 않음)
* 다만, DID를 발급하고 검증할 때 블록체인을 사용할 수 있음

### 블록체인 정보

블록체인은 **중앙 서버 없이 정보를 안전하게 저장하고 검증하는 분산 원장 기술** 이다.

**블록체인의 특징**
* 데이터를 조작할 수 없도록 암호화된 분산 저장 방식
* 거래 기록, 스마트 계약. DID 관련 메타데이터 등을 저장는 기능

* 블록체인은 DID 외에도 다양한 정보를 저장할 수 있음
* 암호화폐 거래 내역
* 스마트 계약
* 분산 애플리케이션(DApp) 관련 데이터
* DID의 공개 키, 신원 발급 기관 정보 등

# 25, 03, 07

### 중앙화 vs 탈중앙화 속도 차이

* 중앙화 시스템 (visa 등) : 1초당 약 2000건 처리 가능, 사용 가능까지 약 3분 소요
* 탈중앙화 시스템(블록체인) : 1초당 약 20건 처리 가능, 평균 10번의 인증(블록 생성)이 필요하여 처리 속도가 느림


### Solidify 개요
* Solidify는 스마트 컨트랙트를 작성하기 위한 언어
* **EVM**을 타겟으로 설계
* 정적타입 언어이며, 상속, 라이브러리, 사용자 데이터 타입 지원
* 스마트 컨트랙트 특징
  * 블로겣인에 업로드 되면 수정 불가, 누구나 확인 가능 -> 신뢰성 높음
  * 코드 작성 시 신중함 필요
* Remix IDE
  * 웹 기반 Solidity 개발 환경
  * 스마트 컨트랙트를 작성하고 실행 테스트 가능

### Solidity 문법 및 개념
#### 스마트 컨트랙트 구조
* 클래스와 유사한 개념으로 구성
  * 상태 변수
  * 함수 및함수 변경자(Modifier)
  * 이밴트(Event)
  * 구조체 (Struct), 열거형(Enum)
  * 상속 및 다형성 지원

#### 데이터 타입
* 문자열: `string`, `byte12` (UTF-8)지원
* 맵핑(Mapping) : `key-value`쌍으로 데이터를 저장(`adress` -> `string` 매핑 예제)
* 배열
  * 정적 배열 : 크기 고정
  * 동적 배열 : 블록체인상에서 지속적으로 추가 가능 -> 데이터베이스처럼 활용 가능
* 인터페이스 (Interface) 추상 계층 설계 가능

#### Modifier(한정자)
* 함수실행 조건을 정의

#### 데이터 저장 위치
* storage : 블록체인에 영구 저장(전역변수)
* memory : 휘발성 메모리(로컬변수)

#### 제어문
* `if`, `else`, `while`, `for`, `break`, `continue`, `return`, 삼항연산자(`? :`) 지원

#### 가시성(Visibility)

|접근제한자|설명|
|---|---|
|`public`|내부 및 외부에서 접근 가능 (자동 Getter 생성)|
|`external`|트랜잭션 또는 다른 컨트랙트에서만 호출 가능(this.f() 필요)|
|`internal`|내부 컨트랙트 및 상속된 컨트랙트에서만 접근 가능|
|`private`|내부 컨트랙트에서만 접근 가능 (상속된 컨트랙트에서도 접근 불가)|

#### 가스(Gas) 개념
* **EVM에서 실행되는 모든 작업에는 수수료(Gas) 필요**
* **가스 = 가스 가격(Gas Price) x 가스 사용량(Gas Used)**
* **가스 리밋(Gas Limit)**
  * 트랜잭션에 사용할 최대 가스 설정
  * 너무 낮게 설정하면 실행 도중 종료되며 사용한 가스는 반환되지 않음
* **가스 프라이스(Gas Price)**
  * 단위 가스당 가격
  * 가격이 높을수록 우선적으로 채굴됨

# 25, 03, 10
## Refresh Token을 사용하는 이유

> **잠깐! Redis는 무엇인가?**
> 레디스는 **인메모리 방식**의 데이터베이스다.


### 베이직 DB와 In-Memory DB 차이
* 기존 DB(mysql, postgreSQL)
	* 보조기억장치(HDD,SDD)에 데이터를 저장한다. 그래서 많은 양의 데이터를 오래 저장하는데 적절하다.
* 인메모리 DB(Redis, MemCache)
	* 주기억장치에 데이터를 저장한다. 그렇기 때문에 조회 성능이 월등히 빠르다.

**단!,** 주기억 장치를 이용하기 때문에 RAM의 휘발성 메모리의 특징도 가지고 있다. 그래서 중요한 데이터의 삭제를 예방하기 위해 fork 기능을 사용하여 보조기억장치에 저장하기도 한다.

> **Radis의 특징 3가지**
> 1. Key-Value 구조
> 2. 데이터 만료시간 설정 가능
> 3. 수평적 확자에 용이

위 특징 때문에 자주 조회되는 값인 Refresh Token을 Redis에 사용하자 라는 말이 많다. 하지만 해당 방식은 아무런 의미가 없다??



## 왜 Refresh Token을 사용할까?

* 완벽한 보안은 존재하지 않다.
* 세션 베이스(statefull) 인증과 '토큰'은 상호 대체적이지 안다.
	* 세션 베이스 인증에서도 토큰을 사용한다.

### 엑세스 토큰의 한계점
*  **잦은 로그아웃**
	* 엑세스 토큰을 단독으로 사용하면 **재발급 시 로그인**을 해야한다.
		* 때문에 만료시간을 짧게 하면 재로그인을 자주 해야하며, 만료시간을 길게하면 아래와 같은 보안 문제가 발생한다.
*  **보안 문제**
	* Access Token의 만료 시간을 길게하면 탈취 당했을 때 유저의 모든 권한을 탈취자가 가지게 된다.
	* 토큰은 statle-less 구조로 state의 주도권을 서버가 가지고 있지 않다.
	* 때문에 탈취 당했다고 하더라도 토큰 자체를 파기할 수 없다.
		* (이는 비용적으로는 장점이지만, 보안적으로는 단점이다.)

### Refresh Token이란?
Refresh Token은 Access Token의 문제점을 방지하기 위해 생겨났다.

* **잦은 로그아웃**
	* Refresh Token을 사용하여 Access Token을 갱신하여 재로그인 주기를 늘릴 수 있다.
* **보안 문제**
	* Access Token의 만료시간을 짧게 함으로써 탈취 시 문제를 조금이나마 방지할 수 있다.


# Refresh Token 탈취 시
* Refresh Token의 한계다. 서버 측에서의 대응이 불가능하다.
	* 이를 예방하기 위해 여러가지 Refresh Token 전략이 존재한다.
	* **상호 대체적인 전략도 존재하며, 상호 보완적 전략도 존재한다.**

## RTR(Refresh Token Roataion)전략
RTR은 Refresh API 사용 시, Acces Token과 함께 Refresh Token을 갱신시켜버리는 방식이다. RTR의 핵심은 **Refresh Token을 1회용으로 구현**하는 것이다.

구현 방식으로는 DB에 저장, rotation_tpye 옵션 사용, Refresh Token의 짧은 만료시간 등이 있다.

대신 XSS 취약점을 사용한 공격은 막지 못한다.

## Refresh Token에 http-only 적용 전략
Access Token은 Http Authorization header에 담아야하기 때문에 노출되는 것을 막을 수 없다. 하지만 리프레시 토큰을 사용할 때는 `http only`옵션을 사용하여 쿠키로 보낸다. JS에선는 Refresh Token에 접근할 수 없기 때문에 위 XSS공격을 예방할 수 있다.

**다만, 이 방법 또한 csrf(Cross-site request forgery)을 사용하면 탈취할 수 있다.**


## Access Token 만료시간 단축 전략
위에서 설명했던 부분이지만, 엑세스 토큰의 만료 시간을 짧게 설정하여 탈취 시 문제를 조금이나마 방지할 수 있다.
* 재발급이 횟수가 늘어나겠지만, **탈취 리스크를 줄이기 위해 권장**하는 방식이다.

## 사용자 정보를 Access Token에 저장 전략
발급 당시 IP, 기기/브라우저 정보 등을 저장하고 엑세스  토큰을 사용하는 자의 정보와 크게 다르다면 재로그인을 수행하는 전략이다. 이 또또한 권장한다.

## Token DB 저장 전략
Access/Refresh Token을 계정에 엑세스 토큰이 1:1로 매핑되도록 DB에 저장하는 방식이다. 
Refresh API를 수행할 때 이미 발급된 Access Token이 탈취 되었을 때 인증서버에서 거부할 수 있다.
이렇게 하면 State-less 구조의 장점을 잃어버린다. 이 방식으로 사용 할 바에는 세션을 사용하는게 맞다 **(Redis를 사용하는 이유에는 보안적인 이유는 없다.)**

## Refresh Token의 한계점
Refresh Token은 한계점이 명확하다. 보안적 역할을 하지 못한다는 평가도 존재한다.
+ 탈취된 Access Token을 만료시킬 수 없다.
+ Refresh Token이 탈취 된다면 결국 아무것도 할 수 없다.


## 이렇게 사용한다(기타 의견)
브라우저 환경인 웹 서비스는 Session을 사용하여 보안성을 가져가고
모바일 환경에서는 상대적으로 해킹이 어렵기 때문에 Token 방식을 사용한다.


# 25, 03, 11

## 순위에 RDB를 사용하지 않는 이유

## 실시간 성능 문제
랭킹 시스템은 보통 실시간으로 데이터를 업데이트 하고 빠르게 조회해야 한다. `RDB`는 데이터 일관성을 유지하기 위해 트랜잭션 관리와 락(lock) 메커니즘을 사용하기 때문에 대량의 쓰기/ 읽기 작업이 반복되는 경우 성능이 저하될 수 있다.

* 랭킹 업데이트 : RDB에서 순위를 계산하려면 매번 정렬 및 순위 계산을 해야할 수 있다. 이는 많은 데이터를 처리해야 하는 경우 매우 느려질 수 있다.
* 실시간 요구사항 : 사용자 수가 많고 랭킹이 자주 변동되는 경우, RDB는 높은 TPS(Transaction Per Second)를 처리하기 어렵다.

## 확장성 문제
`RDB`는 수평 확장이 어려운 경우가 많다. 반면, 랭킹 시스템은 사용자 수가 급격히 증가하거나 데이터 볼륨이 클 경우 수평 확장이 용이한 구조가 필요하다.
* `RDB`는 테이블의 스케일아웃(수평 확장) 보다는 스케일업(하드웨어 성능 강화)에 의존하는 경향이 있어 확장성이 떨어질 수 있다.
* 랭킹 시스템은 대규모 트래픽을 처리해야 하므로 `NoSQL`같은 분산 데이터베이스나 메모리 기반 데이터 저장소(Redis 등)를 사용하는 것이 더 적합할 수 있다.

## 일관성(CAP 이론)의 트레이드오프
랭킹 시스템은 엄격한 데이터 일관성보다 가용성과 성능이 더 중요할 때가 많다. RDB는 [[ACID]] 특성을 제공하지만 이는 성능에 영향을 미칠 수 있다.
* 랭킹 데이터는 실시간으로 자주 변경되고, 일관성 문제가 허용되는 경우가 많다.
* NoSQL이나 Redis를 사용하면 약간의 일관성을 희생하더라도 더 바른 처리 속도를 얻을 수 있다

## Redis와 같은 데이터 저장소의 적합성
랭킹 시스템에서는 보통 Redis와 같은 메모리 기반 데이터 저장소가 많이 사용된다. 이는 랭킹 데이터를 효율적으로 처리하기 위한 적합한 도구를 제공한다.
* `Sorted Set` : Redis의 Sorted Set은 행킹 데이터를 저장하고, 정렬된 상태로 유지하며, 특정 범위의 데이터를 빠르게 조회할 수 있도록 설계되었다.
* `TTL` : 랭킹 시스템에서 데이터의 유효기간을 설정할 수 있어 오래된 데이터를 자동으로 제거할 수 있다.
* `빠른 조회와 업데이트` : 메모리 기반으로 동작하기 떄문에 데이터 조회와 업데이트 속도가 매우 빠르다.

## 비관계형 데이터 모델의 유연성
랭킹 시스템은 보통 단순한 데이터 모델(사용자 ID,  점수 등)을 사용한다. 이런 데이터는 관계형 모델보다는 키-값 또는 정렬된 집합 데이터 모델에서 더 효과적으로 처리할 수 있다.


## 결론
`RDB`는 일반적인 CRUD 작업에는 적합하지만, 랭킹 시스템처럼 대량의 실시간 데이터를 고속으로 처리해야 하는 경우에는 Redis, MongoDB 같은 대체 기술이 더 적합한 경우가 많다. 특히, `Redis`의 **Sorted Set**을 활용하면 성능과 확장성을 동시에 확보할 수 있어 랭킹 시스템에 적합하다.



