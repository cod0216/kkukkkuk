# 김성훈

## 1주차

### 3 / 4
피그마 컴포넌트 기능 중 불리언 설정법 복습
C4D 기본 인터페이스 학습

### 3 / 5
블록체인 기본 개념 학습

### 3 / 6
블록체인 트랜잭션, 스마트 계약, 공개키, 개인키 암호화 방식에 대해 학습

### 3 / 7
리액트, 리액트 네이티브, 플러터 프레임워크 간 차이와 passkey, 지문인식 적용 가능성에 대해 학습

## 2주차

### 3 / 10
블록체인 DID 및 지갑 개념에 대한 이해 및 블록체인 분야의 미래에 대해 학습

### 3 / 11
블록체인 아키텍처 구성, 구글 클라우드 블록체인에서 RAFT 합의를 사용할 때의 최소 호스팅 노드 숫자
- 검증자 노드, RPC 노드, 모니터링 노드로 최소 3가지가 필요함.
- 프론트엔드는 보통 RPC 노드와 소통하는 인터페이스로 작용하며 프론트엔드는 블록체인 네트워크에 직접 들어와 있는 노드로 취급되지 않음
- 백엔드는 노드와 WAS를 구성하며, WAS에서 스마트 계약 작성 모듈과 배포 모듈을 탑재
- 프론트엔드에서의 요청에 맞춰 WAS에서 스마트 계약작성 하는 방식은 '중앙화에 가까움'
- 프론트엔드 부담이 적어지고 캐시를 이용하여 안정적인 서비스가 가능하다는 장점이 있으나 중앙화를 하면 블록체인 사용의 의의가 퇴색됨
- 그렇다면 프론트엔드에서 직접 사용자의 요청에 따라서 직접 호출할 수 있음. 프론트엔드에서 Web3.js를 이용해서 RPC노드로 배포하여 블록체인 네트워크에 스마트계약을 배포함.
- 직접 호출은 탈중앙화라는 의의를 달성할 수 있으나 프론트엔드의 서비스 안정성이 떨어지고, 디바이스 자원을 사용해야하고, 프론트엔드 개발에 단순히 api요청으로 끝나지 않고 스마트 계약 작성모듈과 배포모듈(서비스)를 구현해야한다는 단점이 있음.
- 대부분의 Dapp은 이 때문에 두 방식을 적절히 섞은 하이브리드 방식을 사용하며,
- 완전한 탈중앙화는 서비스의 '목적'을 달성하기 위한 '수단'이기에 탈중앙화가 우리의 목적에 적합한지 안한지 고민해야함.

-> 우리 서비스에서는 먼저 rest요청으로 인증/인가를 WAS를 먼저 거치고 인가 후에는 프론트엔드와 WAS 둘 다 스마트 계약 작성모듈과 배포 모듈을 구현하기로함.

### 3 / 12
블록체인 DID 생성 방법 및 DID 복구 방법 학습
- DID는 개인키를 유추가 불가능한 단방향 함수를 이용하여 공개키로 만들고 그것을 해시화 혹은 그대로 식별자로 사용함.
- 블록체인 네트워크에 did:0x.... 순으로 did가 등록되면 공개키를 이용해서 did를 찾을 수 있음.
- 이 did가 연결된 did 문서를 did를 이용해서 불러올 수 있게 됨.
- 만약 개인키를 소유하고 있는데 did를 분실한 경우, 개인키로부터 공개키를 도출하고, 그것으로 다시 did 식별자를 찾아 did를 가져올 수 있음.
- 따라서 현재 PIN으로 개인키를 암호화하여 서버에 저장하기로 한 우리 서비스에서는 개인키를 분실할 일이 없으니
- DID 관리에 집중할 필요가 다소 줄어듦.
- 그러나 개인키 암호문 서버저장이라는 문제는 피해가기 어려운 것은 사실임
- MVP에 집중한다는 면에서 해당 문제는 후순위로 미뤄도 좋을 것이라 생각함.

### 3 / 13
블록체인 노드 생성 및 트랜잭션 테스트
- docker를 이용해 블록체인 네트워크를 구성하고 네트워크 내에 트랜잭션을 다른 노드에서 볼 수 있는지 확인
- docker에 이미 올라와있는 ethreum image를 이용해 컨테이너를 올려 프라이빗 네트워크를 구성함.
- docker compose geth init을 이용해 제네시스 노드를 초기화함.
- docker compose.yml에 1.bootstrap, 2.ethe1, 3.ethe2, 4. ethe3 4개의 이미지를 빌드, 컨테이너로 실행함.
- 각 컨테이너를 프라이빗 네트워크로 묶어서 연결함.
- docker exec -it [컨테이너명] geth attach 로 콘솔을 불러오고 콘솔 내에 계정을 생성하여 block를 생성함.
- 트랜잭션이 블록에 기록되려면 시간이 걸림. 블록하나에 여러개의 트랜잭션이 들어갈 수도 있음.
- miner 모듈을 설정하면 block을 만들고 트랜젝션을 생성할 수 있음. 이 트랜잭션이 블록으로 기록
- 블록 생성이 완료되면 트랜잭션에 블록 넘버가 붙음.
- 타 노드에서는 이 블록을 주소를 통해 접근할 수 있음.
- 현재 타 노드에서 트랜젝션을 확인하는 것을 테스트 해보지 못했으며, net.peerCount, net.listening 등의 명령으로 노드 연결과 마이닝을 확인함.
- 원래 기록을 하기위해서는 remix ide 등을 이용해 정보를 바이트 코드로 바꿔야한다고함.
- geth는 web3.js를 지원함으로 아마도 계정정보를 이용해 확인을 할 수 있을 것으로 추정.
- 1. 네트워크 내의 타 노드에서도 블록을 조회할 수 있는가, 2. 오프체인에서 인터페이스를 통해 네트워크에 접근하여 정보를 받거나 쓸 수 있는가.
- 3. 2가 가능하다면 기록과 조회에 얼마나 많은 시간이 걸리는가, 4. did가 다를 때 권한 이양은 어떻게 진행하는가
- 1~4의 테스트를 진행하여 기록하고 최적의 방식을 고안해야함.